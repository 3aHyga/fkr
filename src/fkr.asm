/****************************FKR on ADSP 2185********************************/
//#define n 1018
#define n 8
#define ncams 2

.section/data	framedata;
.VAR	FRAME = 0;
.VAR	ROW = 0;
.VAR	CAM_IDX[ncams] = { 0, 0 };
.VAR	CAM_LEN[ncams] = { 0, 0 };

.section/data	bufferdata;
.VAR	BUFFER[n] = "buffer.dat";


.section/pm	interrupts;	/*------Interrupt vector table------*/
	ICNTL = 0x17;		/* Настройка срабатывания прерываний по перепаду */
	IMASK = 8;		/* маскирование всех прерываний кроме прерывания BDMA */
	DIS TIMER;		/* запрет прерываний и тиков таймера */
	JUMP start1;
	POP STS;		/* 0x0004: вектор обработки прерывания кадра (IRQ2) */
	IMASK = 0x207;		/* получение значение регистра IMASK из стека и размаскирование прерывания начала строки */
	PUSH STS;		/* сохранение нового значения регистра IMASK в стек */
	RTI;
start1: I4 = 0x3FE1;		/* 0x0008: IRQL1*/
	M5 = 1; 		/* установка инкрементора M5 в 1 */
	L4 = 0;
	DM(I4,M5) = 0x20;
	DM(I4,M5) = 0x20;	/* 0x000C: IRQL0*/
	DM(I4,M5) = 0;
	DM(I4,M5) = eop - 0x20;
	IDLE;			/* 0x0010: SPORT0 transmit*/
	DIS INTS;		/* 0x0000: вектор обработки прерывания перезагрузки */
	JUMP start;
	nop;
	RTI; nop; nop; nop;	/* 0x0014: SPORT0 receive*/
	RTI; nop; nop; nop;	/* 0x0018: IRQE*/
	RTI; nop; nop; nop;	/* 0x001C: BDMA*/
	DM(I4,M4) = 135;	/* 0x0020: вектор обработки прерывания начала строки (INT1) */
	I0 = BUFFER;		/* настройка счетчика таймера на пропуск 45 импульсов от камер, сброс указателя буфера памяти */
	ENA TIMER;		/* разрешение тиков таймера */
	RTI;
	JUMP int0;	  /* 0x0024: вектор обработки прерывания конца строки (INT0) */
	nop; nop; nop;
	AX0 = IO(0);		/* 0x0028: вектор обработки прерываний от таймера */
	DM(I0,M1) = AX0;	/* чтение данных пришедших с камер из порта воода-вывода и запись значений в память */
	RTI;
	NOP;
	RTI; nop; nop; nop;	/* 0x002C: Power down*/

.section/pm program;
start:	M4 = 0; 		/* установка инкрементора M4 в 0 */
	DM(I4,M5) = 0x70;	/* установка данных в регисте программируемых флагов PF6-4 в 1 */
	DM(I4,M5) = 0x7B00;	/* настройка режима програмируемых флагов на ввод */
	DM(I4,M4) = 0;		/* установка нулевых блоков памяти по умолчанию */
	I4 = 0x3FFB;		/* TSCALE = 0x3FFB, TCOUNT = 0x3FFC, TPERIOD = 0x3FFD */
	DM(I4,M5) = 0;		/* настройка умножителя таймера TSCALE в 1 */
	DM(I4,M5) = 134;	/* настройка счетчика таймера TCOUNT на пропуск 45 импульсов от камер */
	DM(I4,M5) = 2;		/* настройка счетчика таймера TPERIOD на приём сигналов камеры через 180 нс. */
	DM(I4,M5) = 0x7FFF;	/* настройка циклов ожидания IO */
//	  AX0 = DM(I4,M4);
//	  AY0 = 0xE3FF;
//	  AR = AX0 AND AY0;
//	  DM(I4,M4) = AR;
	DM(I4,M4) = 7;		/* настройка порта SPORT1 на прием прерываний IRQ0, IRQ1 */
	I4 = 0x3FF3;		/* регистр управления автозаписью SPORT0 */
	DM(I4,M4) = 0;		/* отключение вывода CLKOUT */
	I4 = 0x3FEF;		/* регистр управления автозаписью SPORT1 */
	DM(I4,M4) = 0;		/* отключение особенностей Powerdown */
	I0 = 0;
	M0 = 0; 		/* установка инкрементора M0 в 0 */
	M1 = 1; 		/* установка инкрементора M1 в 1 */
	IMASK = 0x200;		/* маскирование всех прерываний кроме прерывания кадра */
	I0 = BUFFER;		/* сброс счетчика адреса I0 в 0 */
	L0 = BUFFER + n;
	I2 = FRAME;		/* сброс счетчика адреса I0 в 0 */
	L2 = 6;
	AX0 = 0;
	DM(I2,M0) = AX0;	/* сброс счетчика кадров */
	SE = -1;		/* установка направления и количества сдвигов - вправо на 1 разряд */
	L1 = BUFFER + n;
//	i0 = BUFFER + n;
//	call int0;
//	ena timer;		/* разрешение тиков таймера */
	ENA INTS;		/* разрешение прерываний */
idle1:	IDLE;			/* ожидание прерывания */
	JUMP idle1;
//int1: IMASK = 0x207;	      /* получение значение регистра IMASK из стека и размаскирование прерывания начала строки */
//	PUSH STS;		/* сохранение нового значения регистра IMASK в стек */
//	RTI;
int0:	AX0 = 0;
	DIS TIMER;		/* запрет тиков таймера */
	DM(I2,M1) = AX0;	/* сброс данных строки для обеих камер */
	DM(I2,M1) = AX0;
	DM(I2,M1) = AX0;
	DM(I2,M1) = AX0;
	I2 = CAM_IDX;		/* установка счетчика нулей */
	L2 = CAM_IDX + ncams;
	I3 = CAM_LEN;		/* установка счетчика единиц */
	L3 = CAM_LEN + ncams;
	MX0 = ncams;
	CNTR = ncams;		/* устновка счетчика циклов для обработки сигналов от 2-х камер */
	AX0 = I0;
	AY0 = BUFFER;
	AR = AX0 - AY0, MR1 = AR;
//	if eq jump int0_exit;
int0_loop:	DO int0_loop_exit UNTIL CE;
	CNTR = MR1;		/* устновка счетчика циклов для обработки принятых значений от камеры */
	AX0 = DM(I2,M0);/*+*/	/* чтение значений нулей для строки в регистр AX0 */
	AX1 = DM(I3,M0);/*+*/	/* чтение значений единиц для строки в регистр AX1 */
	I1 = BUFFER;		/* установка счетчика адреса на буфер данных */
int0_loop1:	DO int0_loop_exit1	  UNTIL CE;
	MR0 = DM(I1,M0);	/* чтение бита данных из памяти */
	SR = ASHIFT MR0 (LO), DM(I1,M1) = SR0;	/* сдвиг значения камер вправо на 1 бит и запись полученного после сдвига значения в память */
	AR = TSTBIT 0 OF MR0;	/* проверка младшего бита регистра MR0 */
	IF NE JUMP int0_1;	/* если бит равен 1, то инкрементировать счетчик единиц */
	AF = PASS AX1;
	IF EQ JUMP int0_exec;	/* если значение счетчика единиц равно 0, то инкрементировать счетчик нулей */
	POP	CNTR;		/* выход из цикла обработки */
	CNTR = 1;
	JUMP	int0_loop_exit1;
int0_1: AR = AX1 + 1;		/* инкремент счетчика единиц */
	AX1 = AR;
	JUMP	int0_loop_exit1;
int0_exec:	AR = AX0 + 1;	/* инкремент счетчика нулей */
	AX0 = AR;
int0_loop_exit1:	NOP;
	DM(I2,M1) = AX0;	/* инкрементация указателей данных камеры */
int0_loop_exit: DM(I3,M1) = AX1;
	I0 = 0; 	/* сброс счетчика адреса I0 для вывода в порт */
	CNTR = 6;		/* 6 значений необходимо вывести в порт */
	DO int0_outloop_exit UNTIL CE;
	MR0 = DM(I0,M1);	/* чтение данных из памяти */
	SR = ASHIFT MR0 BY 8 (LO);	/* сдвиг значения на 8 разрядов вправо */
	IO(1) = MR0;		/* вывод в порт регистра SR0 */
int0_outloop_exit:	IO(1) = SR1;		/* вывод в порт регистра SR1 */
	I0 = BUFFER;	/* сброс счетчика памяти */
int0_exit:	RTI;
//	rts;
eop: